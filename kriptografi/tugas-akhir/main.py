# -*- coding: utf-8 -*-
"""Proyek Akhir Kriptografi Kelompok 3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1557vyPANpopvSYT_rvJ4xpWuOW-ZDqDA

**Kelompok 3 Kriptografi:**
- 4611422062 - Ahmad Bagas Aditya Ilham Aulia
- 4611422066 - Rizqi Maulana Ardana
- 4611422069 - Muhammad Fadil Efdika
- 4611422076 - Almaas Izdihar Sant

**Expected Value Result:**
1. Nonlinearity (NL): Achieved a value of **`112`**.
2. Strict Avalanche Criterion (SAC): Achieved a value of **`0.50073`**.
3. Bit Independence Criterion—Nonlinearity (BIC-NL): Achieved a value of **`112`**.
4. Bit Independence Criterion—Strict Avalanche Criterion (BIC-SAC): Achieved a value of **`0.50237`**.
5. Linear Approximation Probability (LAP): Achieved a value of **`0.0625`**.
6. Differential Approximation Probability (DAP): Achieved a value of **`0.015625`**.

# S-Box44
"""

# sbox = [
#     99, 205, 85, 71, 25, 127, 113, 219, 63, 244, 109, 159, 11, 228, 94, 214,
#     77, 177, 201, 78, 5, 48, 29, 30, 87, 96, 193, 80, 156, 200, 216, 86,
#     116, 143, 10, 14, 54, 169, 148, 68, 49, 75, 171, 157, 92, 114, 188, 194,
#     121, 220, 131, 210, 83, 135, 250, 149, 253, 72, 182, 33, 190, 141, 249, 82,
#     232, 50, 21, 84, 215, 242, 180, 198, 168, 167, 103, 122, 152, 162, 145, 184,
#     43, 237, 119, 183, 7, 12, 125, 55, 252, 206, 235, 160, 140, 133, 179, 192,
#     110, 176, 221, 134, 19, 6, 187, 59, 26, 129, 112, 73, 175, 45, 24, 218,
#     44, 66, 151, 32, 137, 31, 35, 147, 236, 247, 117, 132, 79, 136, 154, 105,
#     199, 101, 203, 52, 57, 4, 153, 197, 88, 76, 202, 174, 233, 62, 208, 91,
#     231, 53, 1, 124, 0, 28, 142, 170, 158, 51, 226, 65, 123, 186, 239, 246,
#     38, 56, 36, 108, 8, 126, 9, 189, 81, 234, 212, 224, 13, 3, 40, 64,
#     172, 74, 181, 118, 39, 227, 130, 89, 245, 166, 16, 61, 106, 196, 211, 107,
#     229, 195, 138, 18, 93, 207, 240, 95, 58, 255, 209, 217, 15, 111, 46, 173,
#     223, 42, 115, 238, 139, 243, 23, 98, 100, 178, 37, 97, 191, 213, 222, 155,
#     165, 2, 146, 204, 120, 241, 163, 128, 22, 90, 60, 185, 67, 34, 27, 248,
#     164, 69, 41, 230, 104, 47, 144, 251, 20, 17, 150, 225, 254, 161, 102, 70
# ]

import numpy as np
import tkinter as tk
from tkinter import filedialog, messagebox
import pandas as pd

"""# 1. Pengujian Non Linearity (NL)"""

def binary_representation(num, bits):
    """Convert a number to its binary representation with padding."""
    return [(num >> i) & 1 for i in range(bits)][::-1]

def hadamard_transform(vector):
    """Compute the Hadamard transform of a vector."""
    n = len(vector)
    assert (n & (n - 1)) == 0, "Length of vector must be a power of 2."
    h = vector.copy()
    step = 1
    while step < n:
        for i in range(0, n, step * 2):
            for j in range(step):
                x = h[i + j]
                y = h[i + j + step]
                h[i + j] = x + y
                h[i + j + step] = x - y
        step *= 2
    return h

def calculate_nonlinearity(sbox):
    """Calculate the nonlinearity of the S-box."""
    n = int(np.log2(len(sbox)))  # Input bit size
    m = int(np.log2(max(sbox) + 1))  # Output bit size

    nonlinearity = []

    for bit in range(m):
        # Generate the truth table for the output bit
        truth_table = [((val >> bit) & 1) for val in sbox]
        # Convert truth table to +1/-1 representation
        boolean_function = np.array([1 if x == 1 else -1 for x in truth_table])
        # Compute Hadamard transform
        spectrum = hadamard_transform(boolean_function)
        # Compute nonlinearity for this bit
        max_abs_spectrum = max(abs(spectrum))
        nl = (2**(n - 1)) - (max_abs_spectrum // 2)
        nonlinearity.append(nl)

    # Return the minimum nonlinearity
    return min(nonlinearity)

# print(f"Non Linearity (LP): {sbox_nonlinearity}")
print(f"NL Siap")

"""# 2. Pengujian Strict Avalanche Criterion (SAC)"""

def calculate_sac(sbox):
    """
    Calculate the Strict Avalanche Criterion (SAC) for an S-box.
    SAC measures the dependency of output bits on input bits. For SAC,
    flipping one input bit should flip each output bit with a 50% probability.
    """
    n = int(np.log2(len(sbox)))  # Input bit size
    m = int(np.log2(max(sbox) + 1))  # Output bit size

    sac_matrix = np.zeros((n, m))  # SAC matrix for input-output bit dependency

    for input_bit in range(n):
        for output_bit in range(m):
            # Test flipping each input bit
            flip_count = 0
            for x in range(len(sbox)):
                x_flipped = x ^ (1 << input_bit)  # Flip the input bit
                # Check if the output bit differs
                original_bit = (sbox[x] >> output_bit) & 1
                flipped_bit = (sbox[x_flipped] >> output_bit) & 1
                if original_bit != flipped_bit:
                    flip_count += 1

            # Calculate the proportion of flips
            sac_matrix[input_bit, output_bit] = flip_count / len(sbox)

    # Return the SAC matrix and average SAC value
    average_sac = np.mean(sac_matrix)
    # return sac_matrix, average_sac
    return average_sac

print(f"SAC Siap")

"""# 3. Pengujian Bit Independence Criterion-Nonlinearity (BIC-NL)"""

def calculate_bic_nl(sbox):
    """
    Calculate the Bit Independence Criterion-Nonlinearity (BIC-NL) for an S-box.
    BIC-NL measures how the nonlinearity between pairs of output bits is maintained
    independently when input bits are flipped.
    """
    n = int(np.log2(len(sbox)))  # Input bit size
    m = int(np.log2(max(sbox) + 1))  # Output bit size

    bic_nl_matrix = np.zeros((m, m))  # Matrix for BIC-NL between output bit pairs

    for i in range(m):
        for j in range(m):
            if i == j:
                # Skip diagonal elements since they are self-comparison
                bic_nl_matrix[i, j] = np.nan
                continue

            # Create composite function for output bits i and j
            composite_function = [(sbox[x] >> i) & 1 ^ (sbox[x] >> j) & 1 for x in range(len(sbox))]
            # Convert composite function to +1/-1 representation
            boolean_function = np.array([1 if x == 1 else -1 for x in composite_function])
            # Compute Hadamard transform
            spectrum = hadamard_transform(boolean_function)
            # Compute nonlinearity for this composite function
            max_abs_spectrum = max(abs(spectrum))
            nl = (2**(n - 1)) - (max_abs_spectrum // 2)
            bic_nl_matrix[i, j] = nl

    # Return the BIC-NL matrix and average BIC-NL value
    average_bic_nl = np.nanmean(bic_nl_matrix)  # Exclude NaN values from average
    # return bic_nl_matrix, average_bic_nl
    return average_bic_nl

print(f"BIC-NL Siap")

"""# 4. Pengujian Bit Independence Criterion-Strict Avalanche Criterion (BIC-SAC)"""

def c_bic_sac(sbox, n=8):
    """
    Compute the BIC-SAC (Bit Independence Criterion - Strict Avalanche Criterion).
    This calculates the flipping probability for pairs of output bits when each input bit is flipped.
    """
    sbox_binary = np.array([int_to_bin_array(val, n) for val in sbox])
    bic_sac_matrix = np.zeros((n, n * (n - 1) // 2))  # Input bit vs output bit pairs

    # Generate all unique pairs of output bits (e.g., (0,1), (0,2), ..., (n-2,n-1))
    output_bit_pairs = [(i, j) for i in range(n) for j in range(i + 1, n)]

    for input_bit in range(n):  # Iterate over each input bit
        for input_value in range(len(sbox)):  # Iterate over all possible input values
            flipped_input = input_value ^ (1 << input_bit)  # Flip the `input_bit` in the input value
            if flipped_input >= len(sbox):  # Prevent out-of-bound errors
                continue

            # Get the binary outputs before and after flipping
            original_output = sbox_binary[input_value]
            flipped_output = sbox_binary[flipped_input]

            # XOR to determine changes in output bits
            output_diff = original_output ^ flipped_output

            # Update BIC-SAC for each pair of output bits
            for pair_index, (i, j) in enumerate(output_bit_pairs):
                bic_sac_matrix[input_bit, pair_index] += output_diff[i] ^ output_diff[j]

    # Normalize by dividing by the number of inputs to compute average flipping probability
    bic_sac_matrix /= len(sbox)
    # return bic_sac_matrix, output_bit_pairs
    return np.nanmean(bic_sac_matrix)

def int_to_bin_array(val, n):
    # Convert the integer to binary (removing the '0b' prefix)
    binary_str = bin(val)[2:]
    # Pad the binary string with leading zeros to match the length n
    binary_str = binary_str.zfill(n)
    # Convert the string to an array of integers (0s and 1s)
    return [int(bit) for bit in binary_str]

print(f"BIC-SAC Siap")


"""# 5. Pengujian Linear Approximation Probability (LAP)"""


def dot_product(mask, value):
    return bin(mask & value).count('1') % 2

def calculate_lap(sbox):
    max_lap = 0
    for input_mask in range(1, 256):
        for output_mask in range(1, 256):
            count = sum(
                dot_product(input_mask, x) == dot_product(output_mask, sbox[x])
                for x in range(256)
            )
            lap = abs(count/256 - 0.5)
            max_lap = max(max_lap, lap)
    return max_lap

print(f"LAP Siap")


"""# 6. Pengujian Differential Approximation Probability (DAP)"""

def calculate_dap(sbox):
    """
    Calculate the Differential Approximation Probability (DAP) for an S-box.
    DAP is the maximum probability of a specific input difference mapping to a specific output difference.
    """
    n = int(np.log2(len(sbox)))  # Input bit size
    differential_table = np.zeros((len(sbox), len(sbox)), dtype=int)

    for x in range(len(sbox)):
        for dx in range(len(sbox)):
            dy = sbox[x] ^ sbox[x ^ dx]  # Compute output difference
            differential_table[dx][dy] += 1

    # Normalize the differential table to get probabilities
    total_pairs = len(sbox)
    probability_table = differential_table / total_pairs

    # Find the maximum DAP (excluding zero input and output differences)
    max_dap = np.max(probability_table[1:, 1:])
    # return differential_table, probability_table, max_dap
    return max_dap

def differential_approximation_probability(sbox):
    """
    Fungsi untuk menghitung Differential Approximation Probability (DAP) dari sebuah S-box 16x16.

    :param sbox: Matriks S-box 16x16 yang berisi nilai-nilai dalam desimal
    :return: Matriks probabilitas diferensial
    """
    # Ukuran S-box (16x16)
    n = len(sbox)

    # Matriks untuk menghitung DAP
    dap = np.zeros((n, n), dtype=float)

    # Menentukan semua kemungkinan diferensial input dan output
    for dx in range(n):
        for dy in range(n):
            count = 0  # Untuk menghitung jumlah kejadian yang cocok
            for x1 in range(n):
                x2 = x1 ^ dx  # x2 = x1 ⊕ dx
                y1 = sbox[x1]
                y2 = sbox[x2]
                if (y1 ^ y2) == dy:  # Jika ΔY = dy
                    count += 1

            # Menghitung probabilitas DAP
            dap[dx, dy] = count / n

    return dap

print(f"DAP Siap")

def load_excel_file():
    file_path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
    if file_path:
        try:
            # Membaca data dari Excel, asumsikan S-box berada di satu kolom
            sbox_data = pd.read_excel(file_path, header=None).squeeze().tolist()

            # Memastikan bahwa data S-box yang dimuat adalah list angka
            sbox_textarea.delete("1.0", tk.END)
            sbox_textarea.insert(tk.END, " ".join(map(str, sbox_data)))
            messagebox.showinfo("Success", "S-box berhasil dimuat dari Excel.")
        except Exception as e:
            messagebox.showerror("Error", f"Gagal memuat file: {e}")

def run_test():
    try:
        # Ambil nilai S-box yang dimasukkan sebagai string
        sbox_input_str = sbox_textarea.get("1.0", tk.END).strip()

        if not sbox_input_str:
            messagebox.showerror("Error", "S-box tidak dimuat.")
            return

        # Konversi input string menjadi list integer
        try:
            sbox = [int(x) for x in sbox_input_str.split()]  # Memisahkan berdasarkan spasi dan mengonversi ke integer
        except ValueError:
            messagebox.showerror("Error", "Format S-box salah. Harus berupa angka yang dipisahkan dengan spasi atau koma.")
            return

        # Pilih fungsi pengujian sesuai dengan pilihan
        test_type = test_type_var.get()
        
        if test_type == "Non Linearity":
            result = calculate_nonlinearity(sbox)
        elif test_type == "Strict Avalanche Criterion":
            result = calculate_sac(sbox)
        elif test_type == "BIC-NL":
            result = calculate_bic_nl(sbox)
        elif test_type == "BIC-SAC":
            result = c_bic_sac(sbox)
        elif test_type == "LAP":
            result = calculate_lap(sbox)
        elif test_type == "DAP":
            result = calculate_dap(sbox)
        else:
            messagebox.showerror("Error", "Pilih jenis pengujian.")
            return
        
        # Konversi hasil ke string jika perlu
        if isinstance(result, (int, float)):
            result = str(result)  # Mengonversi angka ke string
        elif isinstance(result, np.ndarray):  # Jika hasilnya array
            result = np.array_str(result)  # Mengonversi array menjadi string

        # Tampilkan hasil
        result_text.delete(1.0, tk.END)
        result_text.insert(tk.END, result)  # Pastikan `result` adalah string

        # Pilihan untuk mengekspor hasil ke Excel
        save_button.config(state="normal")
        
    except Exception as e:
        messagebox.showerror("Error", f"Terjadi kesalahan: {str(e)}")  # Mengonversi exception menjadi string

# Fungsi untuk menyimpan hasil ke Excel
def save_result():
    try:
        result = result_text.get(1.0, tk.END)
        if result.strip() == "":
            messagebox.showerror("Error", "Tidak ada hasil untuk disimpan.")
            return
        
        # Pilih lokasi untuk menyimpan hasil
        save_path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")])
        if save_path:
            result_df = pd.DataFrame([result.splitlines()])
            result_df.to_excel(save_path, index=False, header=False)
            messagebox.showinfo("Success", "Hasil berhasil disimpan.")
    except Exception as e:
        messagebox.showerror("Error", f"Gagal menyimpan hasil: {e}")



# GUI Setup
root = tk.Tk()
root.title("Pengujian S-box")

# Frame untuk input S-box
frame = tk.Frame(root)
frame.pack(pady=10)

label_sbox = tk.Label(frame, text="S-box Input:")
label_sbox.grid(row=0, column=0)

sbox_textarea = tk.Text(frame, height=20, width=50)
sbox_textarea.grid(row=0, column=1, columnspan=2, pady=10)

button_load = tk.Button(frame, text="Load Excel", command=load_excel_file)
button_load.grid(row=1, column=1, sticky="w")

# Frame untuk memilih jenis pengujian

label_test_type = tk.Label(frame, text="Pilih Jenis Pengujian:")
label_test_type.grid(row=2, column=0)

test_type_var = tk.StringVar()
test_type_menu = tk.OptionMenu(frame, test_type_var, "Non Linearity", "Strict Avalanche Criterion", "BIC-NL", "BIC-SAC", "LAP", "DAP")
test_type_menu.grid(row=2, column=1, columnspan=2, sticky="w", pady=20)

# run button
button_run = tk.Button(frame, text="Jalankan Pengujian", command=run_test)
button_run.grid(row=3, column=1, sticky="w")

# Add a divider (using a Frame as a line)
divider = tk.Frame(frame, height=2, bd=1, relief="sunken")
divider.grid(row=4, column=0, columnspan=3, pady=10, sticky="ew")

# Frame untuk menampilkan hasil
label_result = tk.Label(frame, text="Hasil Pengujian:")
label_result.grid(row=5, column=0, columnspan=1)

result_text = tk.Text(frame, height=2, width=35)
result_text.grid(row=5, column=1, pady=10)

save_button = tk.Button(frame, text="Simpan Hasil", command=save_result, state="disabled")
save_button.grid(row=5, column=2)


root.mainloop()
